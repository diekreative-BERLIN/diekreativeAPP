{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport { __assign, __extends } from \"tslib\";\nimport { AnimationFrame } from '@material/animation/animationframe';\nimport { MDCFoundation } from '@material/base/foundation';\nimport { cssClasses, numbers, strings } from './constants';\nvar AnimationKeys = /*#__PURE__*/(() => {\n  (function (AnimationKeys) {\n    AnimationKeys[\"POLL_SCROLL_POS\"] = \"poll_scroll_position\";\n    AnimationKeys[\"POLL_LAYOUT_CHANGE\"] = \"poll_layout_change\";\n  })(AnimationKeys || (AnimationKeys = {}));\n  return AnimationKeys;\n})();\nvar MDCDialogFoundation = /** @class */function (_super) {\n  __extends(MDCDialogFoundation, _super);\n  function MDCDialogFoundation(adapter) {\n    var _this = _super.call(this, __assign(__assign({}, MDCDialogFoundation.defaultAdapter), adapter)) || this;\n    _this.dialogOpen = false;\n    _this.isFullscreen = false;\n    _this.animationFrame = 0;\n    _this.animationTimer = 0;\n    _this.escapeKeyAction = strings.CLOSE_ACTION;\n    _this.scrimClickAction = strings.CLOSE_ACTION;\n    _this.autoStackButtons = true;\n    _this.areButtonsStacked = false;\n    _this.suppressDefaultPressSelector = strings.SUPPRESS_DEFAULT_PRESS_SELECTOR;\n    _this.animFrame = new AnimationFrame();\n    _this.contentScrollHandler = function () {\n      _this.handleScrollEvent();\n    };\n    _this.windowResizeHandler = function () {\n      _this.layout();\n    };\n    _this.windowOrientationChangeHandler = function () {\n      _this.layout();\n    };\n    return _this;\n  }\n  Object.defineProperty(MDCDialogFoundation, \"cssClasses\", {\n    get: function () {\n      return cssClasses;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MDCDialogFoundation, \"strings\", {\n    get: function () {\n      return strings;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MDCDialogFoundation, \"numbers\", {\n    get: function () {\n      return numbers;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MDCDialogFoundation, \"defaultAdapter\", {\n    get: function () {\n      return {\n        addBodyClass: function () {\n          return undefined;\n        },\n        addClass: function () {\n          return undefined;\n        },\n        areButtonsStacked: function () {\n          return false;\n        },\n        clickDefaultButton: function () {\n          return undefined;\n        },\n        eventTargetMatches: function () {\n          return false;\n        },\n        getActionFromEvent: function () {\n          return '';\n        },\n        getInitialFocusEl: function () {\n          return null;\n        },\n        hasClass: function () {\n          return false;\n        },\n        isContentScrollable: function () {\n          return false;\n        },\n        notifyClosed: function () {\n          return undefined;\n        },\n        notifyClosing: function () {\n          return undefined;\n        },\n        notifyOpened: function () {\n          return undefined;\n        },\n        notifyOpening: function () {\n          return undefined;\n        },\n        releaseFocus: function () {\n          return undefined;\n        },\n        removeBodyClass: function () {\n          return undefined;\n        },\n        removeClass: function () {\n          return undefined;\n        },\n        reverseButtons: function () {\n          return undefined;\n        },\n        trapFocus: function () {\n          return undefined;\n        },\n        registerContentEventHandler: function () {\n          return undefined;\n        },\n        deregisterContentEventHandler: function () {\n          return undefined;\n        },\n        isScrollableContentAtTop: function () {\n          return false;\n        },\n        isScrollableContentAtBottom: function () {\n          return false;\n        },\n        registerWindowEventHandler: function () {\n          return undefined;\n        },\n        deregisterWindowEventHandler: function () {\n          return undefined;\n        }\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  MDCDialogFoundation.prototype.init = function () {\n    if (this.adapter.hasClass(cssClasses.STACKED)) {\n      this.setAutoStackButtons(false);\n    }\n    this.isFullscreen = this.adapter.hasClass(cssClasses.FULLSCREEN);\n  };\n  MDCDialogFoundation.prototype.destroy = function () {\n    if (this.animationTimer) {\n      clearTimeout(this.animationTimer);\n      this.handleAnimationTimerEnd();\n    }\n    if (this.isFullscreen) {\n      this.adapter.deregisterContentEventHandler('scroll', this.contentScrollHandler);\n    }\n    this.animFrame.cancelAll();\n    this.adapter.deregisterWindowEventHandler('resize', this.windowResizeHandler);\n    this.adapter.deregisterWindowEventHandler('orientationchange', this.windowOrientationChangeHandler);\n  };\n  MDCDialogFoundation.prototype.open = function (dialogOptions) {\n    var _this = this;\n    this.dialogOpen = true;\n    this.adapter.notifyOpening();\n    this.adapter.addClass(cssClasses.OPENING);\n    if (this.isFullscreen) {\n      // A scroll event listener is registered even if the dialog is not\n      // scrollable on open, since the window resize event, or orientation\n      // change may make the dialog scrollable after it is opened.\n      this.adapter.registerContentEventHandler('scroll', this.contentScrollHandler);\n    }\n    if (dialogOptions && dialogOptions.isAboveFullscreenDialog) {\n      this.adapter.addClass(cssClasses.SCRIM_HIDDEN);\n    }\n    this.adapter.registerWindowEventHandler('resize', this.windowResizeHandler);\n    this.adapter.registerWindowEventHandler('orientationchange', this.windowOrientationChangeHandler);\n    // Wait a frame once display is no longer \"none\", to establish basis for\n    // animation\n    this.runNextAnimationFrame(function () {\n      _this.adapter.addClass(cssClasses.OPEN);\n      if (!dialogOptions || !dialogOptions.isScrimless) {\n        _this.adapter.addBodyClass(cssClasses.SCROLL_LOCK);\n      }\n      _this.layout();\n      _this.animationTimer = setTimeout(function () {\n        _this.handleAnimationTimerEnd();\n        _this.adapter.trapFocus(_this.adapter.getInitialFocusEl());\n        _this.adapter.notifyOpened();\n      }, numbers.DIALOG_ANIMATION_OPEN_TIME_MS);\n    });\n  };\n  MDCDialogFoundation.prototype.close = function (action) {\n    var _this = this;\n    if (action === void 0) {\n      action = '';\n    }\n    if (!this.dialogOpen) {\n      // Avoid redundant close calls (and events), e.g. from keydown on elements\n      // that inherently emit click\n      return;\n    }\n    this.dialogOpen = false;\n    this.adapter.notifyClosing(action);\n    this.adapter.addClass(cssClasses.CLOSING);\n    this.adapter.removeClass(cssClasses.OPEN);\n    this.adapter.removeBodyClass(cssClasses.SCROLL_LOCK);\n    if (this.isFullscreen) {\n      this.adapter.deregisterContentEventHandler('scroll', this.contentScrollHandler);\n    }\n    this.adapter.deregisterWindowEventHandler('resize', this.windowResizeHandler);\n    this.adapter.deregisterWindowEventHandler('orientationchange', this.windowOrientationChangeHandler);\n    cancelAnimationFrame(this.animationFrame);\n    this.animationFrame = 0;\n    clearTimeout(this.animationTimer);\n    this.animationTimer = setTimeout(function () {\n      _this.adapter.releaseFocus();\n      _this.handleAnimationTimerEnd();\n      _this.adapter.notifyClosed(action);\n    }, numbers.DIALOG_ANIMATION_CLOSE_TIME_MS);\n  };\n  /**\n   * Used only in instances of showing a secondary dialog over a full-screen\n   * dialog. Shows the \"surface scrim\" displayed over the full-screen dialog.\n   */\n  MDCDialogFoundation.prototype.showSurfaceScrim = function () {\n    var _this = this;\n    this.adapter.addClass(cssClasses.SURFACE_SCRIM_SHOWING);\n    this.runNextAnimationFrame(function () {\n      _this.adapter.addClass(cssClasses.SURFACE_SCRIM_SHOWN);\n    });\n  };\n  /**\n   * Used only in instances of showing a secondary dialog over a full-screen\n   * dialog. Hides the \"surface scrim\" displayed over the full-screen dialog.\n   */\n  MDCDialogFoundation.prototype.hideSurfaceScrim = function () {\n    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_SHOWN);\n    this.adapter.addClass(cssClasses.SURFACE_SCRIM_HIDING);\n  };\n  /**\n   * Handles `transitionend` event triggered when surface scrim animation is\n   * finished.\n   */\n  MDCDialogFoundation.prototype.handleSurfaceScrimTransitionEnd = function () {\n    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_HIDING);\n    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_SHOWING);\n  };\n  MDCDialogFoundation.prototype.isOpen = function () {\n    return this.dialogOpen;\n  };\n  MDCDialogFoundation.prototype.getEscapeKeyAction = function () {\n    return this.escapeKeyAction;\n  };\n  MDCDialogFoundation.prototype.setEscapeKeyAction = function (action) {\n    this.escapeKeyAction = action;\n  };\n  MDCDialogFoundation.prototype.getScrimClickAction = function () {\n    return this.scrimClickAction;\n  };\n  MDCDialogFoundation.prototype.setScrimClickAction = function (action) {\n    this.scrimClickAction = action;\n  };\n  MDCDialogFoundation.prototype.getAutoStackButtons = function () {\n    return this.autoStackButtons;\n  };\n  MDCDialogFoundation.prototype.setAutoStackButtons = function (autoStack) {\n    this.autoStackButtons = autoStack;\n  };\n  MDCDialogFoundation.prototype.getSuppressDefaultPressSelector = function () {\n    return this.suppressDefaultPressSelector;\n  };\n  MDCDialogFoundation.prototype.setSuppressDefaultPressSelector = function (selector) {\n    this.suppressDefaultPressSelector = selector;\n  };\n  MDCDialogFoundation.prototype.layout = function () {\n    var _this = this;\n    this.animFrame.request(AnimationKeys.POLL_LAYOUT_CHANGE, function () {\n      _this.layoutInternal();\n    });\n  };\n  /** Handles click on the dialog root element. */\n  MDCDialogFoundation.prototype.handleClick = function (evt) {\n    var isScrim = this.adapter.eventTargetMatches(evt.target, strings.SCRIM_SELECTOR);\n    // Check for scrim click first since it doesn't require querying ancestors.\n    if (isScrim && this.scrimClickAction !== '') {\n      this.close(this.scrimClickAction);\n    } else {\n      var action = this.adapter.getActionFromEvent(evt);\n      if (action) {\n        this.close(action);\n      }\n    }\n  };\n  /** Handles keydown on the dialog root element. */\n  MDCDialogFoundation.prototype.handleKeydown = function (evt) {\n    var isEnter = evt.key === 'Enter' || evt.keyCode === 13;\n    if (!isEnter) {\n      return;\n    }\n    var action = this.adapter.getActionFromEvent(evt);\n    if (action) {\n      // Action button callback is handled in `handleClick`,\n      // since space/enter keydowns on buttons trigger click events.\n      return;\n    }\n    // `composedPath` is used here, when available, to account for use cases\n    // where a target meant to suppress the default press behaviour\n    // may exist in a shadow root.\n    // For example, a textarea inside a web component:\n    // <mwc-dialog>\n    //   <horizontal-layout>\n    //     #shadow-root (open)\n    //       <mwc-textarea>\n    //         #shadow-root (open)\n    //           <textarea></textarea>\n    //       </mwc-textarea>\n    //   </horizontal-layout>\n    // </mwc-dialog>\n    var target = evt.composedPath ? evt.composedPath()[0] : evt.target;\n    var isDefault = this.suppressDefaultPressSelector ? !this.adapter.eventTargetMatches(target, this.suppressDefaultPressSelector) : true;\n    if (isEnter && isDefault) {\n      this.adapter.clickDefaultButton();\n    }\n  };\n  /** Handles keydown on the document. */\n  MDCDialogFoundation.prototype.handleDocumentKeydown = function (evt) {\n    var isEscape = evt.key === 'Escape' || evt.keyCode === 27;\n    if (isEscape && this.escapeKeyAction !== '') {\n      this.close(this.escapeKeyAction);\n    }\n  };\n  /**\n   * Handles scroll event on the dialog's content element -- showing a scroll\n   * divider on the header or footer based on the scroll position. This handler\n   * should only be registered on full-screen dialogs with scrollable content.\n   */\n  MDCDialogFoundation.prototype.handleScrollEvent = function () {\n    var _this = this;\n    // Since scroll events can fire at a high rate, we throttle these events by\n    // using requestAnimationFrame.\n    this.animFrame.request(AnimationKeys.POLL_SCROLL_POS, function () {\n      _this.toggleScrollDividerHeader();\n      _this.toggleScrollDividerFooter();\n    });\n  };\n  MDCDialogFoundation.prototype.layoutInternal = function () {\n    if (this.autoStackButtons) {\n      this.detectStackedButtons();\n    }\n    this.toggleScrollableClasses();\n  };\n  MDCDialogFoundation.prototype.handleAnimationTimerEnd = function () {\n    this.animationTimer = 0;\n    this.adapter.removeClass(cssClasses.OPENING);\n    this.adapter.removeClass(cssClasses.CLOSING);\n  };\n  /**\n   * Runs the given logic on the next animation frame, using setTimeout to\n   * factor in Firefox reflow behavior.\n   */\n  MDCDialogFoundation.prototype.runNextAnimationFrame = function (callback) {\n    var _this = this;\n    cancelAnimationFrame(this.animationFrame);\n    this.animationFrame = requestAnimationFrame(function () {\n      _this.animationFrame = 0;\n      clearTimeout(_this.animationTimer);\n      _this.animationTimer = setTimeout(callback, 0);\n    });\n  };\n  MDCDialogFoundation.prototype.detectStackedButtons = function () {\n    // Remove the class first to let us measure the buttons' natural positions.\n    this.adapter.removeClass(cssClasses.STACKED);\n    var areButtonsStacked = this.adapter.areButtonsStacked();\n    if (areButtonsStacked) {\n      this.adapter.addClass(cssClasses.STACKED);\n    }\n    if (areButtonsStacked !== this.areButtonsStacked) {\n      this.adapter.reverseButtons();\n      this.areButtonsStacked = areButtonsStacked;\n    }\n  };\n  MDCDialogFoundation.prototype.toggleScrollableClasses = function () {\n    // Remove the class first to let us measure the natural height of the\n    // content.\n    this.adapter.removeClass(cssClasses.SCROLLABLE);\n    if (this.adapter.isContentScrollable()) {\n      this.adapter.addClass(cssClasses.SCROLLABLE);\n      if (this.isFullscreen) {\n        // If dialog is full-screen and scrollable, check if a scroll divider\n        // should be shown.\n        this.toggleScrollDividerHeader();\n        this.toggleScrollDividerFooter();\n      }\n    }\n  };\n  MDCDialogFoundation.prototype.toggleScrollDividerHeader = function () {\n    if (!this.adapter.isScrollableContentAtTop()) {\n      this.adapter.addClass(cssClasses.SCROLL_DIVIDER_HEADER);\n    } else if (this.adapter.hasClass(cssClasses.SCROLL_DIVIDER_HEADER)) {\n      this.adapter.removeClass(cssClasses.SCROLL_DIVIDER_HEADER);\n    }\n  };\n  MDCDialogFoundation.prototype.toggleScrollDividerFooter = function () {\n    if (!this.adapter.isScrollableContentAtBottom()) {\n      this.adapter.addClass(cssClasses.SCROLL_DIVIDER_FOOTER);\n    } else if (this.adapter.hasClass(cssClasses.SCROLL_DIVIDER_FOOTER)) {\n      this.adapter.removeClass(cssClasses.SCROLL_DIVIDER_FOOTER);\n    }\n  };\n  return MDCDialogFoundation;\n}(MDCFoundation);\nexport { MDCDialogFoundation };\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\nexport default MDCDialogFoundation;\n//# sourceMappingURL=foundation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}