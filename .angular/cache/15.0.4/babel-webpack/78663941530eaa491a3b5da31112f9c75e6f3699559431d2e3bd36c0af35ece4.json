{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nvar FOCUS_SENTINEL_CLASS = 'mdc-dom-focus-sentinel';\n/**\n * Utility to trap focus in a given root element, e.g. for modal components such\n * as dialogs. The root should have at least one focusable child element,\n * for setting initial focus when trapping focus.\n * Also tracks the previously focused element, and restores focus to that\n * element when releasing focus.\n */\nvar FocusTrap = /** @class */function () {\n  function FocusTrap(root, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.root = root;\n    this.options = options;\n    // Previously focused element before trapping focus.\n    this.elFocusedBeforeTrapFocus = null;\n  }\n  /**\n   * Traps focus in `root`. Also focuses on either `initialFocusEl` if set;\n   * otherwises sets initial focus to the first focusable child element.\n   */\n  FocusTrap.prototype.trapFocus = function () {\n    var focusableEls = this.getFocusableElements(this.root);\n    if (focusableEls.length === 0) {\n      throw new Error('FocusTrap: Element must have at least one focusable child.');\n    }\n    this.elFocusedBeforeTrapFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;\n    this.wrapTabFocus(this.root);\n    if (!this.options.skipInitialFocus) {\n      this.focusInitialElement(focusableEls, this.options.initialFocusEl);\n    }\n  };\n  /**\n   * Releases focus from `root`. Also restores focus to the previously focused\n   * element.\n   */\n  FocusTrap.prototype.releaseFocus = function () {\n    [].slice.call(this.root.querySelectorAll(\".\" + FOCUS_SENTINEL_CLASS)).forEach(function (sentinelEl) {\n      sentinelEl.parentElement.removeChild(sentinelEl);\n    });\n    if (!this.options.skipRestoreFocus && this.elFocusedBeforeTrapFocus) {\n      this.elFocusedBeforeTrapFocus.focus();\n    }\n  };\n  /**\n   * Wraps tab focus within `el` by adding two hidden sentinel divs which are\n   * used to mark the beginning and the end of the tabbable region. When\n   * focused, these sentinel elements redirect focus to the first/last\n   * children elements of the tabbable region, ensuring that focus is trapped\n   * within that region.\n   */\n  FocusTrap.prototype.wrapTabFocus = function (el) {\n    var _this = this;\n    var sentinelStart = this.createSentinel();\n    var sentinelEnd = this.createSentinel();\n    sentinelStart.addEventListener('focus', function () {\n      var focusableEls = _this.getFocusableElements(el);\n      if (focusableEls.length > 0) {\n        focusableEls[focusableEls.length - 1].focus();\n      }\n    });\n    sentinelEnd.addEventListener('focus', function () {\n      var focusableEls = _this.getFocusableElements(el);\n      if (focusableEls.length > 0) {\n        focusableEls[0].focus();\n      }\n    });\n    el.insertBefore(sentinelStart, el.children[0]);\n    el.appendChild(sentinelEnd);\n  };\n  /**\n   * Focuses on `initialFocusEl` if defined and a child of the root element.\n   * Otherwise, focuses on the first focusable child element of the root.\n   */\n  FocusTrap.prototype.focusInitialElement = function (focusableEls, initialFocusEl) {\n    var focusIndex = 0;\n    if (initialFocusEl) {\n      focusIndex = Math.max(focusableEls.indexOf(initialFocusEl), 0);\n    }\n    focusableEls[focusIndex].focus();\n  };\n  FocusTrap.prototype.getFocusableElements = function (root) {\n    var focusableEls = [].slice.call(root.querySelectorAll('[autofocus], [tabindex], a, input, textarea, select, button'));\n    return focusableEls.filter(function (el) {\n      var isDisabledOrHidden = el.getAttribute('aria-disabled') === 'true' || el.getAttribute('disabled') != null || el.getAttribute('hidden') != null || el.getAttribute('aria-hidden') === 'true';\n      var isTabbableAndVisible = el.tabIndex >= 0 && el.getBoundingClientRect().width > 0 && !el.classList.contains(FOCUS_SENTINEL_CLASS) && !isDisabledOrHidden;\n      var isProgrammaticallyHidden = false;\n      if (isTabbableAndVisible) {\n        var style = getComputedStyle(el);\n        isProgrammaticallyHidden = style.display === 'none' || style.visibility === 'hidden';\n      }\n      return isTabbableAndVisible && !isProgrammaticallyHidden;\n    });\n  };\n  FocusTrap.prototype.createSentinel = function () {\n    var sentinel = document.createElement('div');\n    sentinel.setAttribute('tabindex', '0');\n    // Don't announce in screen readers.\n    sentinel.setAttribute('aria-hidden', 'true');\n    sentinel.classList.add(FOCUS_SENTINEL_CLASS);\n    return sentinel;\n  };\n  return FocusTrap;\n}();\nexport { FocusTrap };\n//# sourceMappingURL=focus-trap.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}